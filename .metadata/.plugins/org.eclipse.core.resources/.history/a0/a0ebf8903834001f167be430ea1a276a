/*
 * generated by Xtext 2.35.0
 */
package upb.edu.lp.generator;

import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import upb.edu.lp.cocinita.Cocina;
import upb.edu.lp.cocinita.Ingrediente;
import upb.edu.lp.cocinita.Instruccion;
import upb.edu.lp.cocinita.Bowl;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
public class CocinitaGenerator extends AbstractGenerator {

	@Override
	public void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// Extraer el modelo de la receta
		for (Object obj : resource.getContents()) {
			if (obj instanceof Cocina) {
				Cocina cocina = (Cocina) obj;
				String tsCode = generateTypeScriptCode(cocina);
				fsa.generateFile(cocina.getName() + ".ts", tsCode);
			}
		}
	}

	private String generateTypeScriptCode(Cocina cocina) {
		StringBuilder tsCode = new StringBuilder();
		tsCode.append("class " + capitalize(cocina.getName()) + " {\n");
		tsCode.append("\tprivate stack: any[] = [];\n");

		// Agregar ingredientes
		tsCode.append("\tprivate ingredients = {\n");
		for (Ingrediente ingrediente : cocina.getListaIngredientes()) {
			tsCode.append("\t\t" + ingrediente.getName() + ": " + getDefaultValueForType(ingrediente.getTipo()) + ",\n");
		}
		tsCode.append("\t};\n\n");

		// Agregar método principal
		tsCode.append("\tpublic execute() {\n");

		// Generar instrucciones
		for (Instruccion instruccion : cocina.getListaInstrucciones()) {
			tsCode.append("\t\t" + generateInstruction(instruccion) + "\n");
		}

		// Finalizar el método principal
		tsCode.append("\t}\n");

		// Cerrar la clase
		tsCode.append("}\n\n");

		// Crear instancia y ejecutar
		tsCode.append("const recipe = new " + capitalize(cocina.getName()) + "();\n");
		tsCode.append("recipe.execute();\n");

		return tsCode.toString();
	}

	private String generateInstruction(Instruccion instruccion) {
		StringBuilder tsInstruction = new StringBuilder();

		if (instruccion.getIngrediente() != null) {
			tsInstruction.append("this.stack.push(this.ingredients['" + instruccion.getIngrediente().getName() + "']);");
		} else if (instruccion.getExpresion().getBowl() != null) {
			tsInstruction.append("this.stack.push(this.stack[" + (instruccion.getExpresion().getBowl().getNumero() - 1) + "]);");
		}

		switch (instruccion.eClass().getName()) {
			case "Batir":
				tsInstruction.append("this.stack.push(this.stack.pop() + this.stack.pop());");
				break;
			case "Licuar":
				tsInstruction.append("this.stack.push(this.stack.pop() / this.stack.pop());");
				break;
			case "Hornear":
				tsInstruction.append("this.stack.push(this.stack.pop() * this.stack.pop());");
				break;
			case "Refrigerar":
				tsInstruction.append("this.stack.push(this.stack.pop() - this.stack.pop());");
				break;
			case "Agregar":
				tsInstruction.append("this.stack.push(this.ingredients['" + instruccion.getIngrediente().getName() + "']);");
				break;
		}

		return tsInstruction.toString();
	}

	private String getDefaultValueForType(String tipo) {
		switch (tipo) {
			case "[-o]":
				return "0"; // Int
			case "[cU]":
				return "\"\""; // String
			case "[-O]":
				return "false"; // Boolean
			default:
				return "null";
		}
	}

	// Función auxiliar para capitalizar nombres de clases
	private String capitalize(String name) {
		if (name == null || name.isEmpty()) return name;
		return name.substring(0, 1).toUpperCase() + name.substring(1);
	}
}
